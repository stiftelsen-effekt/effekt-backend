generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DB_URL")
}

model Cause_areas {
  ID                   Int       @id @unique(map: "ID_UNIQUE") @default(autoincrement())
  name                 String    @unique(map: "name_UNIQUE") @db.VarChar(45)
  short_desc           String?   @db.VarChar(255)
  long_desc            String?   @db.VarChar(45)
  info_url             String?   @db.VarChar(156)
  is_active            Int?      @db.TinyInt
  ordering             Int?      @db.TinyInt

  Distribution_cause_areas Distribution_cause_areas[]
  Organizations            Organizations[]
}

model Organizations {
  ID                   Int            @id @unique(map: "ID_UNIQUE") @default(autoincrement())
  cause_area_ID        Int            @db.Int
  full_name            String         @unique(map: "full_name_UNIQUE") @db.VarChar(45)
  abbriv               String         @unique(map: "abbriv_UNIQUE") @db.VarChar(10)
  short_desc           String?        @db.VarChar(255)
  long_desc            String         @db.VarChar(45)
  info_url             String?        @db.VarChar(156)
  std_percentage_share Int?           @default(0) @db.TinyInt /// The percentage share of the standard distribution, determined by Effekt. Updated about twice a year
  is_active            Int?           @db.TinyInt
  ordering             Int?           @db.TinyInt

  Cause_areas                           Cause_areas    @relation(fields: [cause_area_ID], references: [ID], onDelete: Cascade, map: "fk_Organizations_to_Cause_areas_idx")
  Distribution_cause_area_organizations Distribution_cause_area_organizations[]
}

model AvtaleGiro_replaced_distributions {
  Original_AvtaleGiro_KID   String    @db.VarChar(15)
  Replacement_KID           String    @id @db.VarChar(15)
  Timestamp                 DateTime? @default(now()) @db.DateTime(0)

  DistributionsOriginal     Distributions @relation(name: "Original", fields: [Original_AvtaleGiro_KID], references: [KID], onDelete: Cascade, map: "fk_AvtaleGiro_replaced_distributions_to_Distributions_idx")
  DistributionsReplacement  Distributions @relation(name: "Replacement", fields: [Replacement_KID], references: [KID], onDelete: Cascade, map: "fk_AvtaleGiro_replaced_distributions_to_Distributions_idx2")
}

model Avtalegiro_agreements {
  ID           Int       @id @default(autoincrement())
  KID          String    @db.VarChar(15)
  amount       Int
  payment_date Int
  notice       Boolean
  active       Boolean   @default(false)
  last_updated DateTime? @default(now()) @db.DateTime(0)
  created      DateTime? @default(now()) @db.DateTime(0)
  cancelled    DateTime? @db.Date

  // If we delete a distribution there should be no agreements with that distribution. Therefore we restrict on deletion of a distribution.
  Distributions Distributions @relation(fields: [KID], references: [KID], onDelete: Restrict, map: "fk_Avtalegiro_agreements_to_Distributions_idx")
}

model Avtalegiro_conversion_reminders {
  ID               Int       @id @default(autoincrement())
  KID              String    @unique(map: "KID_UNIQUE") @db.VarChar(45)
  NumReminders     Int       @default(0)
  LastReminderSent DateTime? @db.DateTime(0)

  Distributions    Distributions @relation(fields: [KID], references: [KID], onDelete: Cascade, map: "fk_Avtalegiro_conversion_reminders_to_Distributions_idx")
}

model Avtalegiro_shipment {
  ID         Int       @id @default(autoincrement())
  num_claims Int?
  generated  DateTime? @default(now()) @db.DateTime(0)
}

model Distributions {
  KID                         String    @id @db.VarChar(15)
  Donor_ID                    Int       
  Tax_unit_ID                 Int?      @default(0)
  Meta_owner_ID               Int       @default(3)
  Replaced_old_organizations  Boolean?  @default(false)
  inserted                    DateTime? @default(now()) @db.DateTime(0)
  last_updated                DateTime? @default(now()) @db.DateTime(0)

  Donors                     Donors    @relation(fields: [Donor_ID], references: [ID], onDelete: Cascade, map: "fk_Distributions_to_Donors_idx")
  Tax_unit                   Tax_unit? @relation(fields: [Tax_unit_ID], references: [ID], onDelete: SetNull, map: "fk_Distributions_to_Tax_unit_idx")
  Data_owner                 Data_owner @relation(fields: [Meta_owner_ID], references: [ID], onDelete: Restrict, map: "fk_Distributions_to_Data_owner_idx")

  Avtalgiro_agreements                            Avtalegiro_agreements[]
  AvtaleGiro_replaced_distributions_original      AvtaleGiro_replaced_distributions[] @relation(name: "Original")
  AvtaleGiro_replaced_distributions_replacement   AvtaleGiro_replaced_distributions[] @relation(name: "Replacement")
  Avtalegiro_conversion_reminders                 Avtalegiro_conversion_reminders[]
  Distribution_cause_areas                        Distribution_cause_areas[]
  Donations                                       Donations[]
  Payment_intent                                  Payment_intent[]
  Paypal_historic_distributions                   Paypal_historic_distributions[]
  Vipps_agreement_charges                         Vipps_agreement_charges[]
  Vipps_agreements                                Vipps_agreements[]
  Vipps_orders                                    Vipps_orders[]
  Swish_orders                                    Swish_order[]
  Vipps_matching_rules                            Vipps_matching_rules[]
}

model Distribution_cause_areas {
  ID                   Int       @id @unique(map: "ID_UNIQUE") @default(autoincrement())
  Distribution_KID     String    @db.VarChar(15)
  Cause_area_ID        Int       @db.Int
  Percentage_share     Decimal   @db.Decimal(15, 12)
  Standard_split       Boolean   @default(false)

  // This is the link to the specific distribtion. If we delete a distribution it should cascade from Distribution -> Distribution_cause_areas -> Distribution_cause_area_organizations to clean up everything.
  Distributions        Distributions  @relation(fields: [Distribution_KID], references: [KID], onDelete: Cascade, map: "fk_Distribution_cause_areas_to_Distributions_idx")
  // Restrict deletion of cause areas. If we delete a cause area there should be no distributions with that cause area.
  Cause_areas          Cause_areas    @relation(fields: [Cause_area_ID], references: [ID], onDelete: Restrict, map: "fk_Distribution_cause_areas_to_Cause_areas_idx")

  Distribution_cause_area_organizations Distribution_cause_area_organizations[]
}

model Distribution_cause_area_organizations {
  ID                              Int       @id @unique(map: "ID_UNIQUE") @default(autoincrement())
  Distribution_cause_area_ID      Int       @db.Int
  Organization_ID                 Int       @db.Int
  Percentage_share                Decimal   @db.Decimal(15, 12)

  // This is the link to the cause area for a specific distribution. If we delete a distribution it should cascade from Distribution -> Distribution_cause_areas -> Distribution_cause_area_organizations to clean up everything.
  Distribution_cause_areas        Distribution_cause_areas  @relation(fields: [Distribution_cause_area_ID], references: [ID], onDelete: Cascade, map: "fk_Distribution_ca_organizations_to_Distribution_ca_idx")
  // Restrict deletion of organization. If we delete an organization there should be no distributions with that organization.
  Organizations                   Organizations  @relation(fields: [Organization_ID], references: [ID], onDelete: Restrict, map: "fk_Distribution_cause_area_organizations_to_Organizations_idx")
}

model Data_owner {
  ID      Int     @id @unique(map: "ID_UNIQUE") @default(autoincrement())
  owner   String  @unique(map: "owner_UNIQUE") @db.VarChar(128)
  default Boolean @default(false)

  Distributions Distributions[]
}


model Donations {
  ID                  Int          @id @unique(map: "ID_UNIQUE") @default(autoincrement()) /// Unik donasjonsID
  Donor_ID            Int /// Foreign key til donor_id
  Payment_ID          Int /// Foreign key til Payment_ID
  PaymentExternal_ID  String?      @unique(map: "PaymentExternal_ID_UNIQUE") @db.VarChar(32) /// Payment ID in external system (ex: Vipps)
  sum_confirmed       Decimal      @db.Decimal(16, 2) /// Donert sum bekreftet fra betalingstjeneste (NOK)
  timestamp_confirmed DateTime     @default(now()) @db.Timestamp(0) /// Timestamp/dato når donasjon er bekreftet fra betalingstjeneste
  transaction_cost    Decimal?     @db.Decimal(16, 2) /// beregnet transaction cost basert på Payment_ID (oppslag på kostnad) og sum confirmed
  KID_fordeling       String       @db.VarChar(16) /// Same as KID. Used to join to Combining_table for distribution percentages (registrert KID fra betalingstjeneste, oppslag i donations_distribution for Donor_ID)
  inserted            DateTime?    @default(now()) @db.Timestamp(0)
  last_updated        DateTime?    @default(now()) @db.Timestamp(0)
  Meta_owner_ID       Int          @default(3)
  Donors              Donors       @relation(fields: [Donor_ID], references: [ID], onDelete: Cascade, map: "fk_Donations_to_Donors_ID")
  Payment             Payment      @relation(fields: [Payment_ID], references: [ID], onDelete: Cascade, map: "fk_Donations_to_Payment")
  Swish_order         Swish_order?

  // When we delete a distribution we delete the associated donations.
  Distributions       Distributions @relation(fields: [KID_fordeling], references: [KID], onDelete: Cascade, map: "fk_Donations_to_Distributions_KID")

  Vipps_orders        Vipps_orders[]

  @@index([KID_fordeling, timestamp_confirmed], map: "KidAndTimestamp")
  @@index([timestamp_confirmed], map: "Timestamp")
  @@index([Donor_ID], map: "fk_Donations_Donors_KID_idx")
  @@index([Payment_ID], map: "fk_Donations_to_Donors_idx")
}

model Donors {
  ID               Int                @id @unique(map: "KID_UNIQUE") @default(autoincrement()) /// Unik kundeID
  email            String             @unique(map: "email_UNIQUE", length: 63) @db.TinyText /// epost registrert i donasjonsskjema,\ntrigger generering av ny donor hvis den ikke eksisterer fra før
  full_name        String?            @db.TinyText
  date_registered  DateTime           @default(now()) @db.Timestamp(0) /// The date the donor first registrered
  password_hash    String?            @db.VarChar(64)
  password_salt    String?            @db.VarChar(32)
  Meta_owner_ID    Int                @default(3)
  newsletter       Boolean?
  trash            Int?               @db.TinyInt
  ssn              String?            @db.VarChar(45)

  Donations        Donations[]
  Distributions    Distributions[]
  FB_payment_ID    FB_payment_ID[]
  Funds_donations  Funds_donations[]
  Tax_unit         Tax_unit[]
  Vipps_agreements Vipps_agreements[]
  Swish_orders     Swish_order[]
  Paypal_historic_distributions Paypal_historic_distributions[]
  Referral_records Referral_records[]
  Vipps_orders     Vipps_orders[]

  @@index([full_name(length: 63)], map: "full_name")
  @@index([email(length: 63), full_name(length: 63)], map: "search")
}

model FB_campaign_org_shares {
  ID             Int      @id @default(autoincrement())
  FB_campaign_ID String   @db.VarChar(20)
  Org_ID         Int
  Share          Decimal  @db.Decimal(15, 12)
  Standard_split Boolean?

  @@index([Org_ID], map: "fk_FB_campaign_org_shares_1_idx")
  @@index([FB_campaign_ID], map: "fk_FB_campaign_org_shares_2_idx")
}

model FB_campaigns {
  ID                  String @id @db.VarChar(20)
  Fundraiser_title    String @db.VarChar(150)
  Source_name         String @db.VarChar(45)
  Permalink           String @db.VarChar(100)
  Campaign_owner_name String @db.VarChar(45)
  Fundraiser_type     String @db.VarChar(45)
}

model FB_donation_reports {
  ID        Int   @id @default(autoincrement())
  FB_report Bytes
}

model FB_payment_ID {
  ID        Int      @id @default(autoincrement())
  donorID   Int
  paymentID String   @db.VarChar(45)
  inserted  DateTime @default(now()) @db.Timestamp(0)
  taxUnitID Int
  Donors    Donors   @relation(fields: [donorID], references: [ID], onDelete: Cascade, map: "donorID")
  Tax_unit  Tax_unit @relation(fields: [taxUnitID], references: [ID], onDelete: Cascade, map: "fk_fbpayment_to_taxunit")

  @@index([donorID], map: "donorID_idx")
  @@index([taxUnitID], map: "fk_fbpayment_to_taxunit_idx")
}

model Funds_donations {
  ID                Int       @id @default(autoincrement())
  DonorID           Int?
  TaxUnitID         Int?
  Sum               Decimal   @db.Decimal(15, 2)
  Timestamp         DateTime  @db.DateTime(0)
  PaymentExternalID String    @db.VarChar(45)
  Donors            Donors?   @relation(fields: [DonorID], references: [ID], onDelete: Cascade, map: "FK_Funds_donorid")
  Tax_unit          Tax_unit? @relation(fields: [TaxUnitID], references: [ID], map: "FK_Funds_taxunit")

  @@index([DonorID], map: "FK_Funds_donorid_idx")
  @@index([TaxUnitID], map: "FK_Funds_taxunit_idx")
}

model Import_logs {
  ID        Int       @id @default(autoincrement())
  label     String?   @db.VarChar(45)
  result    Json?
  timestamp DateTime? @default(now()) @db.DateTime(0)
}

model Payment {
  ID             Int         @id @default(autoincrement())
  payment_name   String      @unique(map: "payment_name_UNIQUE") @db.VarChar(45)
  abbriv         String      @unique(map: "abbriv_UNIQUE") @db.VarChar(45)
  short_desc     String?     @db.VarChar(45)
  flat_fee       Decimal?    @db.Decimal(5, 2) /// Part of the transaction fee that is a constant number
  percentage_fee Decimal?    @db.Decimal(5, 2) /// Part of the transaction fee that is a share of the transaction sum
  lastUpdated    DateTime    @default(now()) @db.Timestamp(0) /// New ID and Payment_name increment with updated fee information
  Donations      Donations[]
}

model Payment_intent {
  Id             Int       @id @unique(map: "Id_UNIQUE") @default(autoincrement())
  Payment_method String?   @db.VarChar(45)
  KID_fordeling  String?   @db.VarChar(20)
  timetamp       DateTime? @default(now()) @db.DateTime(0)

  // When we delete a distribution we save the payment intent for statistics. Simply set the KID to null.
  Distributions Distributions? @relation(fields: [KID_fordeling], references: [KID], onDelete: SetNull, map: "fk_Payment_intent_to_Distributions_idx")

  @@index([KID_fordeling], map: "KID_fordeling_idx")
}

model Paypal_historic_distributions {
  ID                         Int    @id @default(autoincrement())
  Donor_ID                   Int    @unique(map: "Donor_ID_UNIQUE")
  KID                        String @unique(map: "KID_UNIQUE")
  ReferenceTransactionNumber String @unique(map: "ReferenceTransactionNumber_UNIQUE") @db.VarChar(32)

  // When we delete a donor we also delete all associated paypal historic distributions.
  Donors                     Donors @relation(fields: [Donor_ID], references: [ID], onDelete: Cascade, map: "fk_Paypal_historic_distributions_to_Donors_idx")
  // When we delete a distribution we delete the associated paypal historic distributions.
  Distributions              Distributions @relation(fields: [KID], references: [KID], onDelete: Cascade, map: "fk_Paypal_historic_distributions_to_Distributions_idx")
}

model Referral_records {
  ID              Int            @id @default(autoincrement())
  ReferralID      Int
  DonorID         Int?
  Registered      DateTime?      @default(now()) @db.DateTime(0)
  other_comment   String?        @db.VarChar(1000)
  website_session String?        @db.VarChar(45)

  // When deleting a donor we should not delete the referral record. We should set the donor to null.
  Donors          Donors?        @relation(fields: [DonorID], references: [ID], onDelete: SetNull, map: "fk_Referral_records_to_Donors_idx")
  // We don't allow deletion of referral types. If we delete a referral type we should not have any referral records with that type.
  Referral_types  Referral_types @relation(fields: [ReferralID], references: [ID], onDelete: Restrict, map: "referral_type")

  @@index([ReferralID], map: "referral_type_idx")
}

model Referral_types {
  ID               Int                @id @default(autoincrement())
  name             String             @db.VarChar(256)
  is_active        Boolean            @default(true)
  ordering         Int?
  Referral_records Referral_records[]
}

model Swish_order {
  ID              Int        @id @default(autoincrement())
  KID             String     @unique @db.VarChar(15)
  instructionUUID String     @unique @db.VarChar(36) /// Swish uses this to identify the order
  donorID         Int
  donationID      Int?       @unique
  status          String? /// External status from swish
  reference       String     @db.VarChar(32)
  registered      DateTime   @default(now()) @db.DateTime(0)

  donor           Donors     @relation(fields: [donorID], references: [ID], onDelete: Cascade, onUpdate: Cascade)
  donation        Donations? @relation(fields: [donationID], references: [ID], onDelete: Cascade, onUpdate: Cascade)
  Distributions   Distributions @relation(fields: [KID], references: [KID], onDelete: Cascade, onUpdate: Cascade)
}

model Tax_unit {
  ID              Int               @id @default(autoincrement())
  Donor_ID        Int
  ssn             String            @db.VarChar(11)
  full_name       String            @db.VarChar(128)
  registered      DateTime?         @default(now()) @db.DateTime(0)
  archived        DateTime?         @db.DateTime(0)

  FB_payment_ID   FB_payment_ID[]
  Funds_donations Funds_donations[]
  Distributions   Distributions[]

  // When a donor is deleted we also delete the tax unit.
  Donors          Donors            @relation(fields: [Donor_ID], references: [ID], onDelete: Cascade, map: "FK_tax_unit_donor_id")

  @@index([Donor_ID], map: "FK_tax_unit_donor_id_idx")
}

model Vipps_agreement_charges {
  chargeID          String           @unique(map: "chargeID_UNIQUE") @db.VarChar(11)
  agreementID       String           @db.VarChar(20)
  amountNOK         Int              @db.UnsignedInt
  KID               String           @db.VarChar(15)
  dueDate           String           @db.VarChar(100)
  timestamp_created DateTime?        @default(now()) @db.Timestamp(0)
  status            String           @db.VarChar(30)
  type              String?          @db.VarChar(20)

  Vipps_agreements  Vipps_agreements @relation(fields: [agreementID], references: [ID], onDelete: Cascade, map: "FK_agreementID_ID")

  // We don't allow deletion of a distribution with an associated vipps agreement. If we delete a distribution we should not have any vipps agreements with that distribution.
  Distributions     Distributions    @relation(fields: [KID], references: [KID], onDelete: Restrict, map: "FK_KID_KID")

  @@id([chargeID, agreementID])
  @@index([agreementID], map: "FK_ID_agreementID_idx")
}

model Vipps_agreements {
  ID                      String                    @id @db.VarChar(20)
  donorID                 Int
  KID                     String                    @db.VarChar(15)
  amount                  Int
  status                  String?                   @db.VarChar(30)
  monthly_charge_day      Int
  paused_until_date       String?                   @db.VarChar(255)
  agreement_url_code      String                    @db.VarChar(100)
  timestamp_created       DateTime?                 @default(now()) @db.Timestamp(0)
  force_charge_date       String?                   @db.VarChar(100)
  cancellation_date       DateTime?                 @db.Date

  Vipps_agreement_charges Vipps_agreement_charges[]
  Donors                  Donors                    @relation(fields: [donorID], references: [ID], onDelete: Cascade, map: "FK_donorID")

  // We don't allow deletion of a distribution with an associated vipps agreement. If we delete a distribution we should not have any vipps agreements with that distribution.
  Distributions           Distributions             @relation(fields: [KID], references: [KID], onDelete: Cascade, map: "FK_KID")

  @@index([KID], map: "KID_idx")
  @@index([donorID], map: "donorID_idx")
}

model Vipps_matching_rules {
  ID            Int      @id @default(autoincrement())
  SalesLocation String?  @db.VarChar(45)
  Message       String?  @db.VarChar(45)
  PeriodFrom    DateTime @db.Date
  PeriodTo      DateTime @db.Date
  ResolveKID    String   @db.VarChar(32)
  precedence    Int?

  // We don't allow deletion of a distribution with an associated vipps matching rule. If we delete a distribution we should not have any vipps matching rules with that distribution.
  Distributions Distributions @relation(fields: [ResolveKID], references: [KID], onDelete: Restrict, map: "fk_Vipps_matching_rules_to_Distributions_idx")
}

model Vipps_order_transaction_statuses {
  ID            Int      @id @default(autoincrement())
  orderID       String   @db.VarChar(256)
  transactionID String?  @db.VarChar(45)
  amount        Int
  operation     String   @db.VarChar(45)
  timestamp     DateTime @db.DateTime(0)
  success       String   @db.VarChar(45)
}

model Vipps_orders {
  ID         Int       @id @default(autoincrement())
  orderID    String    @db.VarChar(256)
  donorID    Int
  donationID Int?
  KID        String    @db.VarChar(15)
  token      String?   @db.VarChar(256)
  registered DateTime? @default(now()) @db.DateTime(0)

  // When we delete a donor we also delete all associated vipps orders.
  Donors        Donors    @relation(fields: [donorID], references: [ID], onDelete: Cascade, map: "fk_Vipps_orders_to_Donors_idx")
  // When we delete a donation we also delete all associated vipps orders.
  Donations     Donations? @relation(fields: [donationID], references: [ID], onDelete: Cascade, map: "fk_Vipps_orders_to_Donations_idx")
  // When we delete a distribution we also delete all associated vipps orders.
  Distribution  Distributions @relation(fields: [KID], references: [KID], onDelete: Cascade, map: "fk_Vipps_orders_to_Distributions_idx")

  @@index([donationID, orderID], map: "DonationID")
  @@index([donorID], map: "Donor_ID_idx")
  @@index([ID, orderID], map: "ID_order_id")
}

model Vipps_tokens {
  ID      Int      @id @default(autoincrement())
  expires DateTime @db.DateTime(0)
  type    String   @db.VarChar(45)
  token   String   @db.Text
}

model schema_migrations {
  version String @id @db.VarChar(255)
}

model Conversion_rates {
  ID            Int    @id @default(autoincrement())
  Month         Int
  Year          Int
  PaymentMethod String @db.VarChar(45)
  Rate          Float
}
